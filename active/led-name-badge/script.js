let device;

if ("hid" in navigator) {
  navigator.hid.getDevices().then(async (devices) => {
    if (devices.length == 0) return;
    device = devices[0];
    try {
      if (!device.opened) await device.open();
      toggleButtons();
      log(`Device "${device.productName}" is connected and ready.`);
    } catch (error) {
      log(`Error! Try reconnecting to device "${device.productName}".`);
    }
  });

  navigator.hid.addEventListener("disconnect", (event) => {
    log(`Device "${event.device.productName}" got disconnected.`);
    device = null;
    toggleButtons();
  });
} else {
  log("Warning! WebHID is not available. Try Chrome on desktop.");
}

function toggleButtons() {
  updateDeviceButton.disabled = sendGlyphButton.disabled = !device;
}

connectDeviceButton.onclick = async (event) => {
  try {
    const filters = [];
    if (!experimentalCheckbox.checked) {
      filters.push({
        vendorId: 0x0416,
        productId: 0x5020,
      });
    }
    const devices = await navigator.hid.requestDevice({ filters });
    if (devices.length == 0) return;
    device = devices[0];
    if (!device.opened) await device.open();
    toggleButtons();
    log(`Device "${device.productName}" is connected and ready.`);
  } catch (error) {
    log(`Error! ${error}`);
  }
};

updateDeviceButton.onclick = async (event) => {
  const strings = [...document.querySelectorAll(".stringsInput")].map((input) =>
    input.value.trim()
  );
  const brightness = parseInt(document.querySelector("#brightnessInput").value);
  const speeds = [...document.querySelectorAll(".speedInput")].map((input) =>
    parseInt(input.value)
  );
  const modes = [...document.querySelectorAll(".modeInput")].map((input) =>
    parseInt(input.value)
  );
  const height = parseInt(document.querySelector("#heightInput").value);
  try {
    await encodeDataAndSendOutputReport(
      strings,
      brightness,
      speeds,
      modes,
      height
    );
    log(`Device "${device.productName}" has been successfully updated.`);
  } catch (error) {
    log(`Error! ${error}`);
  }
};

// This allows us to abort the update operation.
let controller;

async function encodeDataAndSendOutputReport(
  strings,
  brightness,
  speeds,
  modes,
  height
) {
  if (controller) controller.abort();
  controller = new AbortController();

  let data = encodeHeader(strings, brightness, speeds, modes);
  for (const string of strings) {
    data = data.concat(encodeCharacters(string, height));
  }
  return sendOutputReport(data, controller.signal);
}

function encodeHeader(strings, brightness, speeds, modes) {
  let header = new Array(64);
  header[0] = 0x77; // "w"
  header[1] = 0x61; // "a"
  header[2] = 0x6e; // "n"
  header[3] = 0x67; // "g"

  // Brightness: normal(0), dim(1), max(2)
  if (brightness == 0) header[5] = 0x00;
  else if (brightness == 1) header[5] = 0x20;
  else if (brightness == 2) header[5] = 0x40;

  // Speeds: From 0 to 7 (slow to high)
  // Mode: Scroll-left(0) -right(1) -up(2) -down(3); still-centered(4); animation(5); drop-down(6); curtain(7); laser(8)
  for (let i = 0; i < speeds.length; i++) {
    header[8 + i] = 16 * speeds[i] + modes[i];
  }

  // Strings length
  for (let i = 0; i < strings.length; i++) {
    const length = strings[i].length;
    header[16 + 2 * i] = Math.floor(length / 256);
    header[17 + 2 * i] = length % 256;
  }

  // TODO: Support animations...

  const today = new Date();
  header[38] = today.getFullYear() % 100; // 22 for 2022
  header[39] = today.getMonth() + 1; // 1  for January
  header[40] = today.getDate(); // 19 for 19th
  header[41] = today.getHours();
  header[42] = today.getMinutes();
  header[43] = today.getSeconds();

  return header;
}

const charBitmaps = {
  A: [0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00],
  B: [0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00],
  C: [0x00, 0x7c, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0xc6, 0x7c, 0x00],
  D: [0x00, 0xfc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xfc, 0x00],
  E: [0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00],
  F: [0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00],
  G: [0x00, 0x7c, 0xc6, 0xc6, 0xc0, 0xc0, 0xce, 0xc6, 0xc6, 0x7e, 0x00],
  H: [0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00],
  I: [0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00],
  J: [0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00],
  K: [0x00, 0xe6, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00],
  L: [0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00],
  M: [0x00, 0x82, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00],
  N: [0x00, 0x86, 0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00],
  O: [0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00],
  P: [0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0xf0, 0x00],
  Q: [0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x06],
  R: [0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00],
  S: [0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00],
  T: [0x00, 0x7e, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00],
  U: [0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00],
  V: [0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00],
  W: [0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x82, 0x00],
  X: [0x00, 0xc6, 0xc6, 0x6c, 0x7c, 0x38, 0x7c, 0x6c, 0xc6, 0xc6, 0x00],
  Y: [0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00],
  Z: [0x00, 0xfe, 0xc6, 0x86, 0x0c, 0x18, 0x30, 0x62, 0xc6, 0xfe, 0x00],
  a: [0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00],
  b: [0x00, 0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x00],
  c: [0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00],
  d: [0x00, 0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00],
  e: [0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00],
  f: [0x00, 0x1c, 0x36, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00],
  g: [0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78],
  h: [0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0xe6, 0x00],
  i: [0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00],
  j: [0x0c, 0x0c, 0x00, 0x1c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78],
  k: [0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0xe6, 0x00],
  l: [0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00],
  m: [0x00, 0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6, 0xc6, 0x00],
  n: [0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00],
  o: [0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00],
  p: [0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0],
  q: [0x00, 0x00, 0x00, 0x00, 0x7c, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e],
  r: [0x00, 0x00, 0x00, 0x00, 0xde, 0x76, 0x60, 0x60, 0x60, 0xf0, 0x00],
  s: [0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00],
  t: [0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x34, 0x18, 0x00],
  u: [0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00],
  v: [0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00],
  w: [0x00, 0x00, 0x00, 0x00, 0xc6, 0xd6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00],
  x: [0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00],
  y: [0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0xf8],
  z: [0x00, 0x00, 0x00, 0x00, 0xfe, 0x8c, 0x18, 0x30, 0x62, 0xfe, 0x00],
  0: [0x00, 0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6, 0xc6, 0x7c, 0x00],
  1: [0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00],
  2: [0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00],
  3: [0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00],
  4: [0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x1e, 0x00],
  5: [0x00, 0xfe, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00],
  6: [0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00],
  7: [0x00, 0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00],
  8: [0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00],
  9: [0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0xc6, 0x7c, 0x00],
  " ": [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
};

function encodeCharacters(string, height) {
  const chars = [...string];

  if (!chars.every((char) => char in charBitmaps)) {
    throw new Error(`Invalid character in string "${string}"`);
  }

  return chars.flatMap((char) => {
    const bitmap = [...charBitmaps[char]];
    // Add some spaces above and below if needed.
    while (bitmap.length < height) {
      if (bitmap.length % 2) bitmap.push(0x00);
      else bitmap.unshift(0x00);
    }
    return bitmap;
  });
}

async function sendOutputReport(data, signal) {
  if (signal.aborted) {
    throw new Error("Operation aborted");
  }
  if (data.length > 8192) {
    throw new Error("Writing more than 8192 bytes damages the device");
  }
  const bytes = Uint8Array.from(data.splice(0, 64));
  if (!bytes.length) return;
  await device.sendReport(0, bytes);

  const hexString = [...bytes]
    .map((b) => b.toString(16).padStart(2, "0"))
    .join(" ")
    .toUpperCase();
  log(`>> ${hexString}`);

  return sendOutputReport(data, signal);
}

/* Glyph Editor */

function showCheckboxes(rows, columns) {
  glyphEditor.innerHTML = "";
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < columns; j++) {
      const checkbox = document.createElement("input");
      checkbox.setAttribute("type", "checkbox");
      glyphEditor.append(checkbox);
    }
    const br = document.createElement("br");
    glyphEditor.append(br);
  }
}
showCheckboxes(11, 8);

heightInput.onchange = (event) => {
  showCheckboxes(heightInput.value, 8);
};

sendGlyphButton.onclick = async (event) => {
  if (controller) controller.abort();
  controller = new AbortController();

  // Send unique glyph.
  const brightness = parseInt(document.querySelector("#brightnessInput").value);
  const speeds = [parseInt(document.querySelector(".speedInput").value)];
  const modes = [parseInt(document.querySelector(".modeInput").value)];
  const glyphBytes = [...glyphEditor.querySelectorAll("input[type=checkbox]")]
    .map((i) => (i.checked ? "1" : "0"))
    .join("")
    .split(/(?<=^(?:.{8})+)(?!$)/)
    .map((v) => parseInt(v, 2));
  let data = encodeHeader([" "], brightness, speeds, modes);
  data = data.concat(glyphBytes);
  try {
    await sendOutputReport(data, controller.signal);
    log(`Device "${device.productName}" has been successfully updated.`);
  } catch (error) {
    log(`Error! ${error}`);
  }
};

/* Utils */

function log(text) {
  logs.innerHTML += `${text}<br/>`;
}
